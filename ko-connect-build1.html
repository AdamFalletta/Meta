<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Connect 4 - Blue vs. Pink (Arcade Style)</title>
  <style>
    @font-face {font-family: arcadefont;src: url(ARCADE_N.ttf);format('truetype');}
    @font-face {font-family: digitalfont;src: url(DS-DIGI.TTF);format('truetype');}
    @font-face {font-family: digitalbfont;src: url(DS-DIGIB.TTF);format('truetype');}

    body {
      font-family: arcadefont, sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      background-color: black; 
background: url(img/stars-bg.jpg);
      margin: 0;
      color: #fff;
	overflow:hidden;
    }

    .game-container {
      background-color: #101010;
      padding: 20px;
      border-radius: 12px;
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.6);
      text-align: center;
      max-width: 90%;
      width: fit-content;
      border: 2px solid #333;
    filter: drop-shadow(0px 0px 14px #000000);
    }

    h1 {
      font-size: 6.2em;
 
      background: linear-gradient(#0083ff, #ff00d0);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      text-shadow: 0 0 8px rgba(255,255,255,0.2);
margin-top:40px;
margin-bottom:20px;
    }
    h2 {
      font-size: 2.8em;
      margin-bottom: 15px;
      margin-top:-10px;
      background: linear-gradient(to right, #0083ff, #ff00d0);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      text-shadow: 0 0 8px rgba(255,255,255,0.2);
    }

    #status {
      font-size: 3.2em;
      font-family: digitalbfont;
      color: #73ef29;
      margin-bottom: 10px;
      margin-top:216px;
    }
#game-grid {
  display: grid;
  grid-template-columns: repeat(8, 1fr);
  grid-template-rows: repeat(8, 1fr);
  gap: 8px;
 padding: 10px;
width: 950px; 
height: 950px;
  margin: 0 auto 20px auto;
  background-color: #000;
  border: 0px solid #333;
  border-radius: 8px;
}

    .tile {
      width: 95%;
      height: 95%;
      border-radius: 4px;
      background-color: #101010;
      border: 4px solid;
      border-color: rgba(255, 255, 255, 0.02)
                   rgba(0, 0, 0, 0.1)
                   rgba(0, 0, 0, 0.1)
                   rgba(255, 255, 255, 0.02);
      transition: transform 0.1s ease-out, opacity 0.2s;
      cursor: pointer;
    }

    /* Arcade gradient pieces */
    .tile.blue {
      background: radial-gradient(#0083ff, #001326);
      animation-delay: 0.2s;
      box-shadow: inset 0 0 15px rgba(0,0,0,0.4);
    }

    .tile.pink {
      background: radial-gradient(#ff00d0, #47003a);
      animation-delay: 0.5s;
      box-shadow: inset 0 0 15px rgba(0,0,0,0.4);
    }

    #reset-button {
      padding: 10px 25px;
      font-size: 1.6em;
      background: linear-gradient(#3a3a3a, #343434);
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: transform 0.2s ease;
      box-shadow: 0 4px 12px rgba(0,0,0,0.5);
      font-family: arcadefont;
      text-shadow: 0 0 8px rgba(255,255,255,0.2);
	filter:brightness(.8);
    }

    #reset-button:hover {
      transform: translateY(-2px);
    }

    #reset-button:active {
      transform: translateY(0);
    }

    @media (max-width: 600px) {
      h1 { font-size: 2em; }
      #status { font-size: 1.2em; }
      #game-grid {
        grid-template-columns: repeat(8, min(12vw, 50px));
        grid-template-rows: repeat(8, min(12vw, 50px));
        gap: 5px;
      }
    }

  .matrix {
                position:absolute;
                z-index:6;
                display: grid;
                grid-template-columns: repeat(128, 1fr);
                grid-template-rows: repeat(32, 1fr);
                gap: 2px;
                width:1026px;
                margin-left:-40px;
                margin-top:-40px;
              
                transform:scale(0.6);
                background: #000000;
    border: 18px solid black;
border-radius:4px;
    }
    .cell-dm {
      width: 100%;
      aspect-ratio: 1;
      background-color: #111;
      border-radius: 50%;
    }
    .cell-dm.on {
      background-color: #f00;
    }


  </style>
</head>
<body>
 <img src="img/scanlines.png" style="position:absolute;z-index: 9;opacity: 0.3; margin-top:-450px;pointer-events: none; ">
<img src="img/scanlines.png" style="position:absolute;z-index: 9;opacity: 0.3;margin-top:1706px;pointer-events: none; ">
  <div class="game-container">
    <h1>Knockout</h1>
	<h2>Connect</h2>
         <div class="matrix" id="matrix"></div>

  <script>
    // Define the character map with 8x8 characters
 const charMap = {
  ' ': [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  '.': [0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00],
  '!': [0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 0x00],
  '"': [0x66, 0x66, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00],
  '#': [0x24, 0x24, 0x7E, 0x24, 0x7E, 0x24, 0x24, 0x00],
  '$': [0x18, 0x3E, 0x60, 0x3C, 0x06, 0x7C, 0x18, 0x00],
  '%': [0x62, 0x64, 0x08, 0x10, 0x26, 0x46, 0x00, 0x00],
  '&': [0x30, 0x48, 0x50, 0x20, 0x56, 0x4C, 0x3A, 0x00],
  '\'': [0x18, 0x18, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00],
  '(': [0x0C, 0x18, 0x30, 0x30, 0x30, 0x18, 0x0C, 0x00],
  ')': [0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x18, 0x30, 0x00],
  '*': [0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00],
  '+': [0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00],
  ',': [0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x10],
  '-': [0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00],
  '/': [0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0x80, 0x00],
  ':': [0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x00],
  ';': [0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x10],
  '<': [0x0C, 0x18, 0x30, 0x60, 0x30, 0x18, 0x0C, 0x00],
  '=': [0x00, 0x00, 0x7E, 0x00, 0x00, 0x7E, 0x00, 0x00],
  '>': [0x30, 0x18, 0x0C, 0x06, 0x0C, 0x18, 0x30, 0x00],
  '?': [0x3C, 0x66, 0x06, 0x0C, 0x18, 0x00, 0x18, 0x00],
  '@': [0x3C, 0x66, 0x6E, 0x6A, 0x6E, 0x60, 0x3E, 0x00],
  '[': [0x3C, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3C, 0x00],
  ']': [0x3C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x3C, 0x00],
  '^': [0x10, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0x00],
  '_': [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00],
  '`': [0x30, 0x18, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00],
  '{': [0x0E, 0x0C, 0x0C, 0x38, 0x0C, 0x0C, 0x0E, 0x00],
  '|': [0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00],
  '}': [0x38, 0x0C, 0x0C, 0x0E, 0x0C, 0x0C, 0x38, 0x00],
  '~': [0x00, 0x32, 0x4C, 0x00, 0x00, 0x00, 0x00, 0x00],
  'A': [0x3C, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x66, 0x00],
  'B': [0x7C, 0x66, 0x66, 0x7C, 0x66, 0x66, 0x7C, 0x00],
  'C': [0x3C, 0x66, 0x60, 0x60, 0x60, 0x66, 0x3C, 0x00],
  'D': [0x7C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7C, 0x00],
  'E': [0x7E, 0x60, 0x60, 0x7C, 0x60, 0x60, 0x7E, 0x00],
  'F': [0x7E, 0x60, 0x60, 0x7C, 0x60, 0x60, 0x60, 0x00],
  'G': [0x3C, 0x66, 0x60, 0x6E, 0x66, 0x66, 0x3C, 0x00],
  'H': [0x66, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x66, 0x00],
  'I': [0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00],
  'J': [0x0E, 0x06, 0x06, 0x06, 0x06, 0x66, 0x3C, 0x00],
  'K': [0x66, 0x6C, 0x78, 0x70, 0x78, 0x6C, 0x66, 0x00],
  'L': [0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x7E, 0x00],
  'M': [0x63, 0x77, 0x7F, 0x6B, 0x63, 0x63, 0x63, 0x00],
  'N': [0x66, 0x76, 0x7E, 0x7E, 0x6E, 0x66, 0x66, 0x00],
  'O': [0x3C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00],
  'P': [0x7C, 0x66, 0x66, 0x7C, 0x60, 0x60, 0x60, 0x00],
  'Q': [0x3C, 0x66, 0x66, 0x66, 0x6E, 0x3C, 0x0E, 0x00],
  'R': [0x7C, 0x66, 0x66, 0x7C, 0x6C, 0x66, 0x66, 0x00],
  'S': [0x3C, 0x66, 0x60, 0x3C, 0x06, 0x66, 0x3C, 0x00],
  'T': [0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00],
  'U': [0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00],
  'V': [0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x00],
  'W': [0x66, 0x66, 0x66, 0x66, 0x66, 0x7E, 0x66, 0x00],
  'X': [0x66, 0x66, 0x3C, 0x18, 0x3C, 0x66, 0x66, 0x00],
  'Y': [0x66, 0x66, 0x66, 0x3C, 0x18, 0x18, 0x7E, 0x00],
  'Z': [0x7E, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x7E, 0x00],
  '0': [0x3C, 0x66, 0x6E, 0x76, 0x66, 0x66, 0x3C, 0x00],
  '1': [0x18, 0x38, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00],
  '2': [0x3C, 0x66, 0x06, 0x0C, 0x18, 0x30, 0x7E, 0x00],
  '3': [0x3C, 0x66, 0x06, 0x1C, 0x06, 0x66, 0x3C, 0x00],
  '4': [0x0C, 0x1C, 0x3C, 0x6C, 0x7E, 0x0C, 0x0C, 0x00],
  '5': [0x7E, 0x60, 0x7C, 0x06, 0x06, 0x66, 0x3C, 0x00],
  '6': [0x3C, 0x60, 0x7C, 0x66, 0x66, 0x66, 0x3C, 0x00],
  '7': [0x7E, 0x06, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x00],
  '8': [0x3C, 0x66, 0x66, 0x3C, 0x66, 0x66, 0x3C, 0x00],
  '9': [0x3C, 0x66, 0x66, 0x3E, 0x06, 0x06, 0x3C, 0x00]
};


    const message = "THROW TO START! ".split("");
    const matrix = document.getElementById("matrix");
    const rows = 32;
    const cols = 128;
    const grid = [];

    // Create the matrix grid
    for (let i = 0; i < rows; i++) {
      grid[i] = [];
      for (let j = 0; j < cols; j++) {
        const cell = document.createElement("div");
        cell.className = "cell-dm";
        matrix.appendChild(cell);
        grid[i][j] = cell;
      }
    }

    let offset = 0;
    let colorIndex = 0;
    const colors = ["#f00","#0f0", "#00f", "#ff0", "#f0f"];
    const scrollSpeed = 30; // Speed in milliseconds
    const colorChangeInterval = 100; // Interval to change colors in milliseconds

    // Render the matrix
    function renderMatrix() {
      // Clear the grid
      for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
          grid[i][j].classList.remove("on");
          grid[i][j].style.backgroundColor = "#111";
        }
      }

      // Draw the message
      let col = offset;
      for (const char of message) {
        const glyph = charMap[char] || charMap[' '];
        for (let i = 0; i < glyph.length; i++) {
          const row = glyph[i];
          for (let bit = 0; bit < 8; bit++) {
            if (row & (1 << (7 - bit))) {
              const x = i;
              const y = (col + bit) % cols;
              if (x < rows && y >= 0) {
                grid[x][y].classList.add("on");
                grid[x][y].style.backgroundColor = colors[colorIndex];
              }
            }
          }
        }
        col += 8;
      }

      offset = (offset - 1 + cols) % cols;
    }

    // Scroll the marquee
    function startMarquee() {
      setInterval(() => {
        renderMatrix();
      }, scrollSpeed);
    }

    // Cycle colors after the scroll finishes
    function cycleColors() {
      setInterval(() => {
        colorIndex = (colorIndex + 1) % colors.length;
      }, colorChangeInterval);
    }

    startMarquee();
    cycleColors();
  </script>
    <div id="status"></div>
    <div id="game-grid"></div>
    <button id="reset-button">Play Again!</button>
  </div>

  <script>
    // (JS unchanged from your Connect 4 code)
    // --- Model Layer ---
    const GameModel = (() => {
      const GRID_SIZE = 8;
      let board = [];
      let currentPlayer = 'blue';
      let gameOver = false;
      let movesMade = 0;

      const directions = [
        [0, 1], [1, 0], [1, 1], [1, -1]
      ];

      const initializeBoard = () => {
        board = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(null));
        currentPlayer = 'blue';
        gameOver = false;
        movesMade = 0;
      };

      const placePiece = (row, col, player) => {
        if (board[row][col] === null) {
          board[row][col] = player;
          movesMade++;
          return true;
        }
        return false;
      };

      const checkWin = (row, col, player) => {
        for (const [dRow, dCol] of directions) {
          const count = 1 +
                        countConnected(row, col, dRow, dCol, player) +
                        countConnected(row, col, -dRow, -dCol, player);
          if (count >= 4) return true;
        }
        return false;
      };

      const countConnected = (startRow, startCol, dRow, dCol, player) => {
        let count = 0;
        let r = startRow + dRow;
        let c = startCol + dCol;
        while (r >= 0 && r < GRID_SIZE && c >= 0 && c < GRID_SIZE && board[r][c] === player) {
          count++;
          r += dRow;
          c += dCol;
        }
        return count;
      };

      const isBoardFull = () => movesMade === GRID_SIZE * GRID_SIZE;
      const getBoard = () => board;
      const getCurrentPlayer = () => currentPlayer;
      const setCurrentPlayer = (p) => currentPlayer = p;
      const isGameOver = () => gameOver;
      const setGameOver = (s) => gameOver = s;

      return { initializeBoard, placePiece, checkWin, isBoardFull, getBoard,
               getCurrentPlayer, setCurrentPlayer, isGameOver, setGameOver, GRID_SIZE };
    })();

    // --- View Layer ---
    const GameView = (() => {
      const gameGridElement = document.getElementById('game-grid');
      const statusDisplayElement = document.getElementById('status');
      const resetButtonElement = document.getElementById('reset-button');
      const tiles = [];

      const createGridElements = (gridSize) => {
        gameGridElement.innerHTML = '';
        tiles.length = 0;
        for (let i = 0; i < gridSize; i++) {
          for (let j = 0; j < gridSize; j++) {
            const tile = document.createElement('div');
            tile.classList.add('tile');
            tile.dataset.row = i;
            tile.dataset.col = j;
            gameGridElement.appendChild(tile);
            tiles.push(tile);
          }
        }
      };

      const renderBoard = (boardState) => {
        let tileIndex = 0;
        for (let i = 0; i < boardState.length; i++) {
          for (let j = 0; j < boardState[i].length; j++) {
            const tile = tiles[tileIndex];
            tile.classList.remove('blue', 'pink');
            if (boardState[i][j] !== null) {
              tile.classList.add(boardState[i][j]);
            }
            tileIndex++;
          }
        }
      };

      const updateStatus = (msg) => statusDisplayElement.textContent = msg;
      const addTileClickListeners = (handler) => tiles.forEach(tile => tile.addEventListener('click', handler));
      const removeTileClickListeners = () => tiles.forEach(tile => tile.removeEventListener('click', GameController.handleTileClick));

      return { createGridElements, renderBoard, updateStatus, addTileClickListeners,
               removeTileClickListeners, getResetButton: () => resetButtonElement };
    })();

    // --- Controller Layer ---
    const GameController = (() => {
      let isProcessingClick = false;

      const init = () => {
        GameView.createGridElements(GameModel.GRID_SIZE);
        GameModel.initializeBoard();
        GameView.renderBoard(GameModel.getBoard());
        GameView.updateStatus(`${capitalize(GameModel.getCurrentPlayer())}'s Turn`);
        GameView.addTileClickListeners(handleTileClick);
        GameView.getResetButton().addEventListener('click', resetGame);
      };

      const handleTileClick = (event) => {
        if (GameModel.isGameOver() || isProcessingClick) return;
        isProcessingClick = true;

        const row = parseInt(event.target.dataset.row);
        const col = parseInt(event.target.dataset.col);
        const currentPlayer = GameModel.getCurrentPlayer();
        const piecePlaced = GameModel.placePiece(row, col, currentPlayer);

        if (piecePlaced) {
          GameView.renderBoard(GameModel.getBoard());
          if (GameModel.checkWin(row, col, currentPlayer)) {
            GameView.updateStatus(`${capitalize(currentPlayer)} Wins!`);
            GameModel.setGameOver(true);
            GameView.removeTileClickListeners();
          } else if (GameModel.isBoardFull()) {
            GameView.updateStatus("It's a Draw!");
            GameModel.setGameOver(true);
            GameView.removeTileClickListeners();
          } else {
            GameModel.setCurrentPlayer(currentPlayer === 'blue' ? 'pink' : 'blue');
            GameView.updateStatus(`${capitalize(GameModel.getCurrentPlayer())}'s Turn`);
          }
        } else {
          GameModel.setCurrentPlayer(currentPlayer === 'blue' ? 'pink' : 'blue');
          GameView.updateStatus(`${capitalize(GameModel.getCurrentPlayer())}'s Turn`);
        }

        setTimeout(() => { isProcessingClick = false; }, 100);
      };

      const resetGame = () => {
        GameModel.initializeBoard();
        GameView.renderBoard(GameModel.getBoard());
        GameView.updateStatus(`${capitalize(GameModel.getCurrentPlayer())}'s Turn`);
        GameView.addTileClickListeners(handleTileClick);
      };

      const capitalize = (s) => s.charAt(0).toUpperCase() + s.slice(1);
      return { init, handleTileClick };
    })();

    document.addEventListener('DOMContentLoaded', GameController.init);
  </script>
</body>
</html>

