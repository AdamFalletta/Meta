<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fireworks of Positivity</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #000000;
        }

        canvas {
            display: block;
        }

        /* Dynamically created words will share this base style */
        .word-container {
            position: absolute;
            color: #fff;
            font-family: 'Orbitron', sans-serif;
            font-size: 5vw;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
            opacity: 0;
            pointer-events: none;
            /* Fades in/out over 2 seconds */
            transition: opacity 2s ease-in-out, transform 0.5s ease-out;
            /* Center the word on its origin */
            transform: translate(-50%, -50%) scale(0.8);
            z-index: 10;
        }

        .word-container.show {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
        }
    </style>
</head>
<body>
    <canvas id="fireworksCanvas"></canvas>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('fireworksCanvas');
            const ctx = canvas.getContext('2d');

            let fireworks = [];
            let particles = [];
            let words = [
                "Joy", "Hope", "Peace", "Love", "Faith", "Strong", "Kind", "Inspire",
                "Create", "Brave", "Dream", "Radiant", "Glow", "Thrive", "Grow",
                "Light", "Cherish", "Calm", "Relax", "Bliss", "Smile", "Happy",
                "Believe", "Courage", "Clarity", "Sparkle", "Wonder", "Energy",
                "Freedom", "Grace", "Harmony", "Patience", "Wisdom", "Trust",
                "Honest", "Balance", "Serene", "Vital", "Unique", "Limitless",
                "Infinite", "Vibrant", "Resilient", "Empower", "Motivate", "Focus",
                "Positive", "Success", "Gratitude", "Healing", "Abundance", "Awe",
                "Beauty", "Compassion", "Confidence", "Content", "Courageous", "Dazzle",
                "Delight", "Determination", "Devotion", "Dynamic", "Elevate", "Embrace",
                "Enchanted", "Enlighten", "Enthusiasm", "Excite", "Exuberant", "Flourish",
                "Fortitude", "Genuine", "Gentle", "Heartfelt", "Illuminated", "Immerse",
                "Inner", "Journey", "Jubilant", "Kinship", "Laughter", "Lively", "Majestic",
                "Magnify", "Mindful", "Nurture", "Openness", "Passion", "Persevere",
                "Prosperity", "Radiate", "Rejoice", "Renew", "Resolve", "Resplendent",
                "Serenity", "Shine", "Sincerity", "Spirited", "Splendor", "Stellar",
                "Sublime", "Triumph", "True", "Unite", "Uplift", "Venture", "Victory",
                "Zeal", "Zenith", "Accomplish", "Achieve", "Adore", "Affection",
                "Ambitious", "Amiable", "Appreciate", "Ascend", "Authentic", "Awesome",
                "Brilliance", "Captivate", "Celebrate", "Cheerful", "Compassionate",
                "Courage", "Create", "Dedication", "Delightful", "Determined", "Dignity",
                "Dynamic", "Effortless", "Embrace", "Empowered", "Encourage", "Enrich",
                "Equanimity", "Esteem", "Excellence", "Fabulous", "Fantastic", "Fearless",
                "Flawless", "Flourish", "Fulfillment", "Generosity", "Glorious", "Gratitude",
                "Harmonious", "Heartfelt", "Heroic", "Honesty", "Hopeful", "Humility",
                "Illumination", "Imaginative", "Inspiring", "Integrity", "Intrepid", "Invincible",
                "Jubilant", "Kindness", "Knowledge", "Leadership", "Legendary", "Liberate",
                "Luminous", "Magnificent", "Mastery", "Merit", "Miraculous", "Motivated",
                "Noble", "Nurturing", "Optimism", "Passion", "Patience", "Perseverance",
                "Playful", "Positive", "Powerful", "Prosper", "Purpose", "Quest",
                "Quintessential", "Radiant", "Rejoice", "Reliable", "Resilience", "Respect",
                "Resplendent", "Sensation", "Serendipity", "Serene", "Shine", "Sincere",
                "Splendor", "Strength", "Success", "Superb", "Tender", "Terrific",
                "Thoughtful", "Thrive", "Tranquil", "Transform", "Treasure", "Triumphant",
                "Trustworthy", "Truthful", "Unwavering", "Uplifted", "Valor", "Vibrant",
                "Victory", "Virtuous", "Vivacious", "Vivid", "Warmhearted", "Welcoming",
                "Well-being", "Whimsical", "Wholesome", "Willful", "Winning", "Wondrous",
                "Zestful", "Zealous"
            ];
            let lastWordIndex = -1;
            let twinklingStars = [];
            // Increased the number of stars for a denser look
            const STAR_COUNT = 300; 

            const setupCanvas = () => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            };

            window.addEventListener('resize', setupCanvas);
            setupCanvas();

            function getRandomInt(min, max) {
                return Math.floor(Math.random() * (max - min + 1)) + min;
            }

            function getRandomColor() {
                const colors = [
                    '#FF5733', '#FFBD33', '#75FF33', '#33FFBD', '#33B5FF', '#3357FF',
                    '#7533FF', '#BD33FF', '#FF33BD', '#FF3357', '#e600e6', '#00e6e6',
                    '#ffe600', '#ff0066', '#3399ff', '#66ff33'
                ];
                return colors[getRandomInt(0, colors.length - 1)];
            }

            function hexToRgb(hex) {
                let r = parseInt(hex.slice(1, 3), 16);
                let g = parseInt(hex.slice(3, 5), 16);
                let b = parseInt(hex.slice(5, 7), 16);
                return `${r}, ${g}, ${b}`;
            }

            // Function to generate a lightning bolt shape
            const createLightningBoltParticles = (x, y, color) => {
                const segments = [
                    { x1: -70, y1: 0, x2: 0, y2: -100 },
                    { x1: 0, y1: -100, x2: 25, y2: -100 },
                    { x1: 25, y1: -100, x2: 0, y2: -160 },
                    { x1: 0, y1: -160, x2: -40, y2: -130 },
                    { x1: -40, y1: -130, x2: -15, y2: -200 }
                ];

                segments.forEach(seg => {
                    const dx = seg.x2 - seg.x1;
                    const dy = seg.y2 - seg.y1;
                    const len = Math.sqrt(dx * dx + dy * dy);
                    const count = Math.ceil(len / 5);

                    for (let i = 0; i < count; i++) {
                        const t = i / (count - 1);
                        const px = x + seg.x1 + dx * t;
                        const py = y + seg.y1 + dy * t;
                        particles.push(new Particle(px, py, color, 0));
                    }
                });
            };

            // Function to generate a heart shape
            const createHeartParticles = (x, y, color) => {
                const particleCount = 400;
                const scale = 50;
                for (let i = 0; i < particleCount; i++) {
                    const t = Math.random() * 2 * Math.PI;
                    const heartX = 16 * Math.pow(Math.sin(t), 3);
                    const heartY = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
                    const particleX = x + heartX * scale / 16;
                    const particleY = y - heartY * scale / 16;
                    particles.push(new Particle(particleX, particleY, color, 0));
                }
            };
            
            // Function to generate a star shape
            const createStarParticles = (x, y, color) => {
                const particleCount = 200;
                const radius = 80;
                for (let i = 0; i < particleCount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const r = Math.random() * radius;
                    const particleX = x + r * Math.cos(angle);
                    const particleY = y + r * Math.sin(angle);
                    particles.push(new Particle(particleX, particleY, color, 0));
                }
            };
            
            class Firework {
                constructor() {
                    this.x = canvas.width / 2;
                    this.y = canvas.height;
                    
                    this.targetX = Math.random() * canvas.width;
                    this.targetY = Math.random() * (canvas.height * 0.6) + (canvas.height * 0.2); 
                    
                    this.color = getRandomColor();
                    // Increased speed for a faster ascent to reduce delay
                    this.speed = Math.random() * 2 + 3; 
                    this.angle = Math.atan2(this.targetY - this.y, this.targetX - this.x);
                    this.vx = Math.cos(this.angle) * this.speed;
                    this.vy = Math.sin(this.angle) * this.speed;
                    this.finished = false;
                    this.life = 0;
                    this.size = Math.random() * 2 + 1;
                    
                    // Randomly choose a shape for this firework
                    const shapes = ['circle', 'heart', 'lightning', 'star'];
                    this.shape = shapes[Math.floor(Math.random() * shapes.length)];
                }

                update() {
                    this.x += this.vx;
                    this.y += this.vy;
                    this.life++;
                    if (this.y <= this.targetY || (this.vx > 0 && this.x >= this.targetX) || (this.vx < 0 && this.x <= this.targetX)) {
                        this.finished = true;
                        this.explode();
                    }
                }

                draw() {
                    const blinkAlpha = 0.5 + Math.sin(this.life * 0.2) * 0.5;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, 3, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(${hexToRgb(this.color)}, ${blinkAlpha})`;
                    ctx.fill();
                }

                explode() {
                    // Create particles based on the chosen shape
                    switch (this.shape) {
                        case 'heart':
                            createHeartParticles(this.x, this.y, this.color);
                            break;
                        case 'lightning':
                            createLightningBoltParticles(this.x, this.y, this.color);
                            break;
                        case 'star':
                            createStarParticles(this.x, this.y, this.color);
                            break;
                        case 'circle':
                        default:
                            const particleCount = this.size * 250;
                            const particleSpeed = (Math.random() * 3 + 2) * (this.size * 0.5 + 0.5);
                            for (let i = 0; i < particleCount; i++) {
                                particles.push(new Particle(this.x, this.y, this.color, particleSpeed));
                            }
                            break;
                    }
                    this.showWord();
                }

                showWord() {
                    let newWordIndex;
                    do {
                        newWordIndex = Math.floor(Math.random() * words.length);
                    } while (newWordIndex === lastWordIndex);
                    lastWordIndex = newWordIndex;

                    const newWordElement = document.createElement('div');
                    newWordElement.className = 'word-container';
                    newWordElement.textContent = words[newWordIndex];
                    newWordElement.style.color = this.color;
                    
                    // Increased font size for a more prominent effect
                    newWordElement.style.fontSize = `${Math.random() * 2 + 5}vw`;
                    
                    document.body.appendChild(newWordElement);
                    
                    // Get the word's dimensions after it's in the DOM
                    const wordWidth = newWordElement.offsetWidth;
                    const wordHeight = newWordElement.offsetHeight;

                    // Calculate the position, keeping it within the canvas boundaries
                    let adjustedX = this.x;
                    let adjustedY = this.y;

                    // Clamp the x-position to prevent being cut off
                    if (adjustedX < wordWidth / 2) {
                        adjustedX = wordWidth / 2;
                    } else if (adjustedX > canvas.width - wordWidth / 2) {
                        adjustedX = canvas.width - wordWidth / 2;
                    }

                    // Clamp the y-position to prevent being cut off
                    if (adjustedY < wordHeight / 2) {
                        adjustedY = wordHeight / 2;
                    } else if (adjustedY > canvas.height - wordHeight / 2) {
                        adjustedY = canvas.height - wordHeight / 2;
                    }

                    newWordElement.style.top = `${adjustedY}px`;
                    newWordElement.style.left = `${adjustedX}px`;

                    setTimeout(() => {
                        newWordElement.classList.add('show');
                    }, 50);

                    setTimeout(() => {
                        newWordElement.classList.remove('show');
                        setTimeout(() => {
                            if (newWordElement.parentNode) {
                                newWordElement.parentNode.removeChild(newWordElement);
                            }
                        }, 2000);
                    }, 4000);
                }
            }

            class Particle {
                constructor(x, y, color, speed) {
                    this.x = x;
                    this.y = y;
                    this.color = color;
                    this.size = Math.random() * 2 + 1;
                    this.angle = Math.random() * Math.PI * 2;
                    this.speed = Math.random() * speed + 1;
                    this.vx = Math.cos(this.angle) * this.speed;
                    this.vy = Math.sin(this.angle) * this.speed;
                    this.gravity = 0.05;
                    this.friction = 0.98;
                    this.alpha = 1;
                }

                update() {
                    this.x += this.vx;
                    this.y += this.vy;
                    this.vy += this.gravity;
                    this.vx *= this.friction;
                    this.vy *= this.friction;
                    this.alpha -= 0.002;
                }

                draw() {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(${hexToRgb(this.color)}, ${this.alpha})`;
                    ctx.shadowColor = this.color;
                    ctx.shadowBlur = 15;
                    ctx.fill();
                }
            }

            class TwinklingStar {
                constructor() {
                    this.x = Math.random() * canvas.width;
                    this.y = Math.random() * canvas.height;
                    // Increased star size for visibility
                    this.size = Math.random() * 3 + 1.5; 
                    this.alpha = Math.random();
                    this.speed = Math.random() * 0.01 + 0.005;
                    this.direction = Math.random() > 0.5 ? 1 : -1;
                }
                
                update() {
                    this.alpha += this.speed * this.direction;
                    if (this.alpha > 1 || this.alpha < 0) {
                        this.direction *= -1;
                        this.alpha = Math.max(0, Math.min(1, this.alpha));
                    }
                }

                draw() {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(255, 255, 255, ${this.alpha})`;
                    ctx.fill();
                }
            }

            const createTwinklingStars = () => {
                for (let i = 0; i < STAR_COUNT; i++) {
                    twinklingStars.push(new TwinklingStar());
                }
            };
            createTwinklingStars();

            const animate = () => {
                ctx.fillStyle = '#000000'; 
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw stars first so they are in the background
                for (let i = 0; i < twinklingStars.length; i++) {
                    twinklingStars[i].update();
                    twinklingStars[i].draw();
                }

                // Set shadow properties once for all particles
                ctx.shadowColor = 'rgba(255, 255, 255, 0.5)';
                ctx.shadowBlur = 10;

                // Use a backward for loop to safely remove finished fireworks
                for (let i = fireworks.length - 1; i >= 0; i--) {
                    const fw = fireworks[i];
                    fw.update();
                    fw.draw();
                    if (fw.finished) {
                        fireworks.splice(i, 1);
                    }
                }

                // Use a backward for loop to safely remove faded particles
                for (let i = particles.length - 1; i >= 0; i--) {
                    const p = particles[i];
                    p.update();
                    p.draw();
                    if (p.alpha <= 0.01) {
                        particles.splice(i, 1);
                    }
                }
                
                // Reset shadow properties for other drawing
                ctx.shadowBlur = 0;
                ctx.shadowColor = 'rgba(0, 0, 0, 0)';

                requestAnimationFrame(animate);
            };

            const launchFirework = () => {
                const maxFireworks = 2; // Maximum number of fireworks allowed at once
                if (fireworks.length < maxFireworks) {
                    fireworks.push(new Firework());
                }
                const delay = getRandomInt(1000, 3000);
                setTimeout(launchFirework, delay);
            };

            setTimeout(launchFirework, 1000); 
            animate();
        });
    </script>
</body>
</html>
